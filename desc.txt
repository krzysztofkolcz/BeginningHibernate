==maven multi module:==
http://books.sonatype.com/mvnex-book/reference/multimodule-sect-intro.html
mvn archetype:generate -DgroupId=org.sonatype.mavenbook -DartifactId=simple -Dpackage=org.sonatype.mavenbook -Dversion=1.0-SNAPSHOT 
wyszukiwania dependencies: https://repository.sonatype.org/

==websystique001==
projectHibernate na podstawie:
http://websystique.com/springmvc/spring-4-mvc-and-hibernate4-integration-example-using-annotations/
oraz spring security:
http://websystique.com/spring-security/spring-security-4-hello-world-annotation-xml-example/
Wykorzystane również liquibase

==websystiqueSecurity002LoginForm==
http://maven.apache.org/archetype/maven-archetype-plugin/usage.html
http://websystique.com/spring-security/spring-security-4-custom-login-form-annotation-example/


==websystiqueSecurity004ViewLayer==
Zabezpieczenie fragmentów widoku
http://websystique.com/spring-security/spring-security-4-secure-view-layer-using-taglibs/


==HibernateExample:==
http://www.mastertheboss.com/jboss-frameworks/maven-tutorials/maven-hibernate-jpa/maven-and-hibernate-4-tutorial
!!!
mvn compile exec:java -Dexec.mainClass=com.mastertheboss.hibernate.HibernateTest 
Couldn't destroy threadgroup hibernate:
Sesja mysql nie jest poprawnie zamykana. Należy dodać flagę:
http://stackoverflow.com/questions/29878937/how-to-properly-close-hibernate-session-with-mysql-server
-Dexec.cleanupDaemonThreads=false



==websystiqueHibernate001Hello:==
Problem z manifest file, przy odpaleniu
java -jar target/HibernateStandAloneDemo.jar
Próbuje mvn shade plugin:
https://maven.apache.org/plugins/maven-shade-plugin/examples/executable-jar.html
To wywołanie coś wreszcie daje!:
java -cp target/HibernateStandAloneDemo.jar com.websystique.hibernate.HibernateStandAloneDemo 
http://books.sonatype.com/mvnex-book/reference/simple-project-sect-building-simple.html
Niestety daje tyle:
Session Factory could not be created.java.lang.NoClassDefFoundError: org/hibernate/cfg/Configuration
...
... 2 more
Caused by: java.lang.ClassNotFoundException: org.hibernate.cfg.Configuration
Próbuje:
mvn compile exec:java -Dexec.mainClass=com.websystique.hibernate.HibernateStandAloneDemo 
Ok, działa, jest tylko problem z nieistniejącą tabelką bazy danych.
Pomogło dodanie go hibernate.cfg.xml:
        <property name="hbm2ddl.auto">create-drop</property>
wywołany program nie kończy się,  dodaje flagę z HibernateExample:
-Dexec.cleanupDaemonThreads=false

mvn compile exec:java -Dexec.mainClass=com.websystique.hibernate.HibernateStandAloneDemo -Dexec.cleanupDaemonThreads=false




==websystiqueHibernate002Annotations:== 
http://websystique.com/hibernate/hibernate-mysql-maven-hello-world-example-annotation/
mvn archetype:generate -DgroupId=com.websystique.hibernate -DartifactId=websystiqueHibernateAnnotations002 -Dpackage=com.websystique.hibernate -Dversion=1.0

dodanie plików migracji do src/main/resources/liquibase
changelog.xml
db.1.xml
...

cd ~/liquibase
Zmiana propertisów w liquibase.properties:

driver=com.mysql.jdbc.Driver 
classpath=/home/krzysztof/.m2/repository/mysql/mysql-connector-java/5.1.38/mysql-connector-java-5.1.38.jar
changeLogFile=/home/krzysztof/IdeaProjects/BeginningHibernate/websystique001/src/main/resources/liquibase/changelog.xml 
url=jdbc:mysql://localhost/hibernate_test
username=hibernate_test
password=hibernate_test

java -jar liquibase.jar migrate

dodanie dependencies:
hibernate-core
mysql-connector-java

dodanie klasy modelu z annotacjami
dodanie pliku hibernate.cfg.xml do src/main/resources

mvn clean package
mvn compile exec:java -Dexec.mainClass=com.websystique.hibernate.HibernateStandAloneDemo -Dexec.cleanupDaemonThreads=false

wywołanie:
java -cp target/websystiqueHibernateAnnotations002-1.0.jar com.websystique.hibernate.HibernateStandAloneDemo
nie działa:
Caused by: java.lang.ClassNotFoundException: org.hibernate.cfg.AnnotationConfiguration
dodanie classpath do jarów w .m2 również nie działa
java 

Próbuje zrboić standalone jar, na podstawie:
http://stackoverflow.com/questions/574594/how-can-i-create-an-executable-jar-with-dependencies-using-maven
poszło wreszcie na podstawie tej odpowiedzi:
http://stackoverflow.com/questions/1814526/problem-building-executable-jar-with-maven
oraz tej sekcji pliku pom:

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.3.2</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <showDeprecation>true</showDeprecation>
                    <showWarnings>true</showWarnings>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>2.2</version>
            </plugin>
            <plugin>
              <groupId>org.apache.maven.plugins</groupId>
              <artifactId>maven-assembly-plugin</artifactId>
              <version>2.2-beta-4</version>
              <configuration>
                <descriptorRefs>
                  <descriptorRef>jar-with-dependencies</descriptorRef>
                </descriptorRefs>
                <archive>
                  <manifest>
                    <mainClass>com.websystique.hibernate.HibernateStandAloneDemo</mainClass>
                  </manifest>
                </archive>
              </configuration>
              <executions>
                <execution>
                  <phase>package</phase>
                  <goals>
                    <goal>single</goal>
                  </goals>
                </execution>
              </executions>
            </plugin>
        </plugins>
    </build>







Kompilacja i uruchomienie programu z linii komend:
The Java File
TheJavaFile.java

Compile the Java File to a *.class file
javac TheJavaFile.java

This will create a TheJavaFile.class file
Execution of the Java File
java TheJavaFile

Creation of an executable *.jar file
You've got two options here -
With an external manifest file :
Create the manifest file say - MANIFEST.mf
The MANIFEST file is nothing but an explicit entry of the Main Class
jar -cvfm TheJavaFile.jar MANIFEST.mf TheJavaFile.class
Executable by Entry Point:
jar -cvfe TheJavaFile.jar <MainClass> TheJavaFile.class
To run the Jar File
java -jar TheJavaFile.jar


==websystiqueHibernate003OneToOneUniPK==
bez problemów, zrobiony dependency jar

One to One unidirectional

create table STUDENT (
   student_id BIGINT NOT NULL AUTO_INCREMENT,
   first_name VARCHAR(30) NOT NULL,
   last_name  VARCHAR(30) NOT NULL,
   section    VARCHAR(30) NOT NULL,
   PRIMARY KEY (student_id)
);
 
 
create table ADDRESS (
   address_id BIGINT NOT NULL,
   street VARCHAR(30) NOT NULL,
   city  VARCHAR(30) NOT NULL,
   country  VARCHAR(30) NOT NULL,
   PRIMARY KEY (address_id),
   CONSTRAINT student_address FOREIGN KEY (address_id) REFERENCES STUDENT ( student_id) ON DELETE CASCADE 
);

@Entity
@Table(name = "STUDENT")
public class Student {
 
    @Id
    @GeneratedValue
    @Column(name = "STUDENT_ID")
    private long id;
 
    @Column(name = "FIRST_NAME")
    private String firstName;
 
    @Column(name = "LAST_NAME")
    private String lastName;
 
    @Column(name = "SECTION")
    private String section;
 
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private Address address;
...
}

@Entity
@Table(name = "ADDRESS")
public class Address {
 
    @Id
    @Column(name = "ADDRESS_ID")
    private long id;
 
    @Column(name = "STREET")
    private String street;
 
    @Column(name = "CITY")
    private String city;
 
    @Column(name = "COUNTRY")
    private String country;
...
}

package com.websystique.hibernate;
 
import java.util.List;
 
import org.hibernate.Session;
 
import com.websystique.hibernate.model.Address;
import com.websystique.hibernate.model.Student;
 
public class HibernateStandAlone {
     
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
 
        Student student = new Student("Sam","Disilva","Maths");
        Address address = new Address("10 Silver street","NYC","USA");
         
         
        Session session = HibernateUtil.getSessionFactory().openSession();
        session.beginTransaction();
 
        session.persist(student);
         
        address.setId(student.getId());
        student.setAddress(address);
        session.save(student);
         
        List<Student> students = (List<Student>)session.createQuery("from Student ").list();
        for(Student s: students){
            System.out.println("Details : "+s);
        }
         
        session.getTransaction().commit();
        session.close();  
    }
 
}








==websystiqueHibernate004OneToOneUniFKA==
One To One Unidirectional Foreign Key

mvn archetype:generate -DgroupId=com.websystique.hibernate -DartifactId=websystiqueHibernate004OneToOneUniFKA -Dpackage=com.websystique.hibernate -Dversion=1.0-SNAPSHOT 

create table ADDRESS (
   address_id BIGINT NOT NULL AUTO_INCREMENT,
   street VARCHAR(30) NOT NULL,
   city  VARCHAR(30) NOT NULL,
   country  VARCHAR(30) NOT NULL,
   PRIMARY KEY (address_id)
);
 
create table STUDENT (
   student_id BIGINT NOT NULL AUTO_INCREMENT,
   home_address_id BIGINT NOT NULL,
   first_name VARCHAR(30) NOT NULL,
   last_name  VARCHAR(30) NOT NULL,
   section    VARCHAR(30) NOT NULL,
   PRIMARY KEY (student_id),
   CONSTRAINT student_address FOREIGN KEY (home_address_id) REFERENCES ADDRESS ( address_id)
);

@Entity
@Table(name = "STUDENT")
public class Student {
 
    @Id
    @GeneratedValue
    @Column(name = "STUDENT_ID")
    private long id;
 
    @Column(name = "FIRST_NAME")
    private String firstName;
 
    @Column(name = "LAST_NAME")
    private String lastName;
 
    @Column(name = "SECTION")
    private String section;
 
    @OneToOne
    @JoinColumn(name="HOME_ADDRESS_ID")
    private Address address;
...
}

@Entity
@Table(name = "ADDRESS")
public class Address {
 
    @Id @GeneratedValue
    @Column(name = "ADDRESS_ID")
    private long id;
 
    @Column(name = "STREET")
    private String street;
 
    @Column(name = "CITY")
    private String city;
 
    @Column(name = "COUNTRY")
    private String country;
...
}

@SuppressWarnings("unchecked")
    public static void main(String[] args) {
 
        Student student = new Student("Sam","Disilva","Maths");
        Address address = new Address("10 Silver street","NYC","USA");
         
         
        Session session = HibernateUtil.getSessionFactory().openSession();
        session.beginTransaction();
 
        session.persist(address);
        student.setAddress(address);
        session.persist(student);
 
        List<Student> students = (List<Student>)session.createQuery("from Student ").list();
        for(Student s: students){
            System.out.println("Details : "+s);
        }
         
        session.getTransaction().commit();
        session.close();  
    }


==websystiqueHibernate005OneToOneBiSharedPK==
Nie zaimplementowane
One To One Bidirectional with shared pk
http://websystique.com/hibernate/hibernate-one-to-one-bidirectional-with-shared-primary-key-annotation-example/

create table STUDENT (
   student_id BIGINT NOT NULL AUTO_INCREMENT,
   first_name VARCHAR(30) NOT NULL,
   last_name  VARCHAR(30) NOT NULL,
   section    VARCHAR(30) NOT NULL,
   PRIMARY KEY (student_id)
);
 
 
create table ADDRESS (
   address_id BIGINT NOT NULL,
   street VARCHAR(30) NOT NULL,
   city  VARCHAR(30) NOT NULL,
   country  VARCHAR(30) NOT NULL,
   PRIMARY KEY (address_id),
   CONSTRAINT student_address FOREIGN KEY (address_id) REFERENCES STUDENT ( student_id) ON DELETE CASCADE 
);

@Entity
@Table(name = "STUDENT")
public class Student {
 
    @Id
    @GeneratedValue
    @Column(name = "STUDENT_ID")
    private long id;
 
    @Column(name = "FIRST_NAME")
    private String firstName;
 
    @Column(name = "LAST_NAME")
    private String lastName;
 
    @Column(name = "SECTION")
    private String section;
 
    @OneToOne(mappedBy="student", cascade = CascadeType.ALL)
    private Address address;
...
}

@Entity
@Table(name = "ADDRESS")
public class Address {
 
    @Id
    @Column(name="ADDRESS_ID")
    @GeneratedValue(generator="gen")
    @GenericGenerator(name="gen", strategy="foreign",parameters=@Parameter(name="property", value="student"))
    private long id;
 
    @Column(name = "STREET")
    private String street;
 
    @Column(name = "CITY")
    private String city;
 
    @Column(name = "COUNTRY")
    private String country;
 
    @OneToOne
    @PrimaryKeyJoinColumn
    private Student student;
...
}

Note that now we have a student property in Address class and address property in Student class, which means we can now navigate in either direction.In hibernate, for bidirectional relationships like this, we have a concept of ownership, means who is the owner of this relationship.Put simply, who is responsible for updating the column in DB on which this relationship depends on. In our case it’s the student_id of Student table which is driving the complete relationship truck. So we should tell hibernate that it’s the Student class which will manage the relationship.

To do that, we can use mappedBy attribute. mappedBy attribute are always put(annotated) on the inverse side of relation ship and specifies with it’s attribute value, the owner of the relationship.

@OneToOne(mappedBy="student", cascade = CascadeType.ALL)
private Address address;

With this declaration, we ask hibernate to go and find the student property of Address class to know how to manage the relationship/perform some operation. Now in Address class , we have following declaration

@OneToOne
@PrimaryKeyJoinColumn
private Student student;
Which simply says that both the Address table and Student table share the same primary key.

    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
 
        Student student = new Student("Sam","Disilva","Maths");
        Address address = new Address("10 Silver street","NYC","USA");
         
         
        Session session = HibernateUtil.getSessionFactory().openSession();
        session.beginTransaction();
 
        student.setAddress(address);
        address.setStudent(student);
        session.save(student);
         
        List<Student> students = (List<Student>)session.createQuery("from Student ").list();
        for(Student s: students){
            System.out.println("Details : "+s);
        }
         
        session.getTransaction().commit();
        session.close();  
    }



==websystiqueHibernate006ManyToOneUni==

create table UNIVERSITY (
   university_id BIGINT NOT NULL AUTO_INCREMENT,
   name VARCHAR(30) NOT NULL,
   country  VARCHAR(30) NOT NULL,
   PRIMARY KEY (university_id)
);
 
create table STUDENT (
   student_id BIGINT NOT NULL AUTO_INCREMENT,
   university_id BIGINT NOT NULL,
   first_name VARCHAR(30) NOT NULL,
   last_name  VARCHAR(30) NOT NULL,
   section    VARCHAR(30) NOT NULL,
   PRIMARY KEY (student_id),
   CONSTRAINT student_university FOREIGN KEY (university_id) REFERENCES UNIVERSITY (university_id) ON UPDATE CASCADE ON DELETE CASCADE
);


@Entity
@Table(name = "UNIVERSITY")
public class University {
 
    @Id
    @GeneratedValue
    @Column(name = "UNIVERSITY_ID")
    private long id;
 
    @Column(name = "NAME")
    private String name;
 
    @Column(name = "COUNTRY")
    private String country;
 
    public University() {
 
    }
...
}

@Entity
@Table(name = "STUDENT")
public class Student {
... 
    @ManyToOne(optional = false)
    @JoinColumn(name="UNIVERSITY_ID")
    private University university;
...
}

@ManyToOne indicates that Many student tuples can refer to one University tuple. 
Also note that we have provided optional=false means this relationship becomes mandatory , 
no student row can be saved without a university tuple reference.
@JoinColumn says that there is a column UNIVERSITY_ID in Student table which will refer(foreign key) to primary key of the University table. 
In this example only Student to University entity navigation is possible. Not viceversa. 
In practice, however, you are free to use query language to find all the student for a given university.


@SuppressWarnings("unchecked")
    public static void main(String[] args) {
 
        Student student1 = new Student("Sam","Disilva","Maths");
        Student student2 = new Student("Joshua", "Brill", "Science");
        Student student3 = new Student("Peter", "Pan", "Physics");
         
        University university = new University("CAMBRIDGE", "ENGLAND");
 
        student1.setUniversity(university);
        student2.setUniversity(university);
        student3.setUniversity(university);
 
 
        Session session = HibernateUtil.getSessionFactory().openSession();
        session.beginTransaction();
 
        session.persist(university);
        session.persist(student1);
        session.persist(student2);
        session.persist(student3);
         
        List<Student> students = (List<Student>)session.createQuery("from Student ").list();
        for(Student s: students){
            System.out.println("Details : "+s);
            System.out.println("Student University Details: "+s.getUniversity());
        }
         
        session.getTransaction().commit();
        session.close();  
    }

==websystiqueHibernate007ManyToOneBi==

create table UNIVERSITY (
   university_id BIGINT NOT NULL AUTO_INCREMENT,
   name VARCHAR(30) NOT NULL,
   country  VARCHAR(30) NOT NULL,
   PRIMARY KEY (university_id)
);
 
create table STUDENT (
   student_id BIGINT NOT NULL AUTO_INCREMENT,
   university_id BIGINT NOT NULL,
   first_name VARCHAR(30) NOT NULL,
   last_name  VARCHAR(30) NOT NULL,
   section    VARCHAR(30) NOT NULL,
   PRIMARY KEY (student_id),
   CONSTRAINT student_university FOREIGN KEY (university_id) REFERENCES UNIVERSITY (university_id) ON UPDATE CASCADE ON DELETE CASCADE
);

@Entity
@Table(name = "UNIVERSITY")
public class University {
...
    @OneToMany(mappedBy = "university", cascade = CascadeType.ALL)
    private List<Student> students;
...
}

@Entity
@Table(name = "STUDENT")
public class Student {
... 
    @ManyToOne(optional = false)
    @JoinColumn(name = "UNIVERSITY_ID")
    private University university;
...
}

@OneToMany on list property here denotes that one University can have multiple students.
With students property defined in University class, we can now navigate from University to students.
mappedBy says that it’s the inverse side of relationship.
Also note the cascade attribute, which means the dependent object(Student) will be persisted/updated/deleted automatically 
on subsequent persist/update/delete on University object.
No need to perform operation separately on Student.

@JoinColumn says that Student table will contain a separate column UNIVERSITY_ID which will eventually act i
as a foreign key reference to primary key of University table. 
@ManyToOne says that multiple Student tuples can refer to same University Tuples(Multiple students can register in same university).
Additionally , with optional=false we make sure that no Student tuple can exist without a University tuple.

   @SuppressWarnings("unchecked")
    public static void main(String[] args) {
 
        Student student1 = new Student("Sam", "Disilva", "Maths");
        Student student2 = new Student("Joshua", "Brill", "Science");
        Student student3 = new Student("Peter", "Pan", "Physics");
 
        University university = new University("CAMBRIDGE", "ENGLAND");
        List<Student> allStudents = new ArrayList<Student>();
 
        student1.setUniversity(university);
        student2.setUniversity(university);
        student3.setUniversity(university);
 
        allStudents.add(student1);
        allStudents.add(student2);
        allStudents.add(student3);
 
        university.setStudents(allStudents);
 
        Session session = HibernateUtil.getSessionFactory().openSession();
        session.beginTransaction();
 
        session.persist(university);// Students will be presisted automatically, thanks to CASCADE.ALL defined on students
                                    // property of University class.
 
        List<Student> students = (List<Student>) session.createQuery(
                "from Student ").list();
        for (Student s : students) {
            System.out.println("Student Details : " + s);
            System.out.println("Student University Details: "
                    + s.getUniversity());
        }
 
        // Note that now you can also access the relationship from University to Student
 
        session.getTransaction().commit();
        session.close();
    }

==websystiqueHibernate008ManyToManyUni==
http://websystique.com/hibernate/hibernate-many-to-many-unidirectional-annotation-example/

create table STUDENT (
   student_id BIGINT NOT NULL AUTO_INCREMENT,
   first_name VARCHAR(30) NOT NULL,
   last_name  VARCHAR(30) NOT NULL,
   PRIMARY KEY (student_id)
);
 
 
create table SUBJECT (
   subject_id BIGINT NOT NULL AUTO_INCREMENT,
   name VARCHAR(30) NOT NULL,
   PRIMARY KEY (subject_id)
);
 
 
CREATE TABLE STUDENT_SUBJECT (
    student_id BIGINT NOT NULL,
    subject_id BIGINT NOT NULL,
    PRIMARY KEY (student_id, subject_id),
    CONSTRAINT FK_STUDENT FOREIGN KEY (student_id) REFERENCES STUDENT (student_id),
    CONSTRAINT FK_SUBJECT FOREIGN KEY (subject_id) REFERENCES SUBJECT (subject_id)
);

@Entity
@Table(name = "STUDENT")
public class Student {
 
    @Id
    @GeneratedValue
    @Column(name = "STUDENT_ID")
    private long id;
 
    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name = "STUDENT_SUBJECT", 
             joinColumns = { @JoinColumn(name = "STUDENT_ID") }, 
             inverseJoinColumns = { @JoinColumn(name = "SUBJECT_ID") })
    private List<Subject> subjects = new ArrayList<Subject>();

....
}

package com.websystique.hibernate.model;
 
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;
 
@Entity
@Table(name = "SUBJECT")
public class Subject {
 
    @Id
    @GeneratedValue
    @Column(name = "SUBJECT_ID")
    private long id;
 
    @Column(name = "NAME")
    private String name;
...
}

Subject is a plain POJO, with no details of Student

@ManyToMany indicates that there is a Many-to-Many relationship between Student and subject.
A Student can enroll for multiple subjects, and a subject can have multiple students enrolled.
Notice cascade = CascadeType.ALL, with cascading while persisting (update/delete) Student tuples,
subjects tuples will also be persisted (updated/deleted).

@JoinTable indicates that there is a link table which joins two tables via containing there keys.
This annotation is mainly used on the owning side of the relationship.
joinColumns refers to the column name of owning side(STUDENT_ID of STUDENT),
 and inverseJoinColumns refers to the column of inverse side of relationship(SUBJECT_ID of SUBJECT).
Primary key of this joined table is combination of STUDENT_ID & SUBJECT_ID.

'''One important remark : In case of *Many* association, always override hashcode and equals method which are looked by hibernate when holding entities into collections.'''
i    public static void main(String[] args) {
 
        Student student1 = new Student("Sam","Disilva");
        Student student2 = new Student("Joshua", "Brill");
         
        Subject subject1 = new Subject("Economics");
        Subject subject2 = new Subject("Politics");
        Subject subject3 = new Subject("Foreign Affairs");
 
        //Student1 have 3 subjects
        student1.getSubjects().add(subject1);
        student1.getSubjects().add(subject2);
        student1.getSubjects().add(subject3);
         
        //Student2 have 2 subjects
        student2.getSubjects().add(subject1);
        student2.getSubjects().add(subject2);
 
        Session session = HibernateUtil.getSessionFactory().openSession();
        session.beginTransaction();
 
        session.persist(student1);
        session.persist(student2);
         
        session.getTransaction().commit();
        session.close();  
    }


==websystiqueHibernate009ManyToManyBi==
http://websystique.com/hibernate/hibernate-many-to-many-bidirectional-annotation-example/
create table STUDENT (
   student_id BIGINT NOT NULL AUTO_INCREMENT,
   first_name VARCHAR(30) NOT NULL,
   last_name  VARCHAR(30) NOT NULL,
   PRIMARY KEY (student_id)
);
 
 
create table SUBJECT (
   subject_id BIGINT NOT NULL AUTO_INCREMENT,
   name VARCHAR(30) NOT NULL,
   PRIMARY KEY (subject_id)
);
 
 
CREATE TABLE STUDENT_SUBJECT (
    student_id BIGINT NOT NULL,
    subject_id BIGINT NOT NULL,
    PRIMARY KEY (student_id, subject_id),
    CONSTRAINT FK_STUDENT FOREIGN KEY (student_id) REFERENCES STUDENT (student_id),
    CONSTRAINT FK_SUBJECT FOREIGN KEY (subject_id) REFERENCES SUBJECT (subject_id)
);

@Entity
@Table(name = "STUDENT")
public class Student {
 
    @Id
    @GeneratedValue
    @Column(name = "STUDENT_ID")
    private long id;
 
    /*...other columns...*/ 

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name = "STUDENT_SUBJECT", 
        joinColumns = { @JoinColumn(name = "STUDENT_ID") }, 
        inverseJoinColumns = { @JoinColumn(name = "SUBJECT_ID") })
    private List<Subject> subjects = new ArrayList<Subject>();
/*...rest code...*/
}

@Entity
@Table(name = "SUBJECT")
public class Subject {
 
    @Id
    @GeneratedValue
    @Column(name = "SUBJECT_ID")
    private long id;
 
    /*...other columns...*/ 

    @ManyToMany(mappedBy="subjects")
    private List<Student> students = new ArrayList<Student>();
/*...rest code...*/
}

Only change in this relationship( ManyToMany Bidirectional) and ManyToMany Unidirectional is that,
in the Subject class we have added following property.

@ManyToMany(mappedBy="subjects")
private List<Student> students = new ArrayList<Student>();


Test:

    public static void main(String[] args) {
 
        Student student1 = new Student("Sam","Disilva");
        Student student2 = new Student("Joshua", "Brill");
         
        Subject subject1 = new Subject("Economics");
        Subject subject2 = new Subject("Politics");
        Subject subject3 = new Subject("Foreign Affairs");
 
        //Student1 have 3 subjects
        student1.getSubjects().add(subject1);
        student1.getSubjects().add(subject2);
        student1.getSubjects().add(subject3);
         
        //Student2 have 2 subjects
        student2.getSubjects().add(subject1);
        student2.getSubjects().add(subject2);
 
        Session session = HibernateUtil.getSessionFactory().openSession();
        session.beginTransaction();
 
        session.persist(student1);
        session.persist(student2);
 
        session.getTransaction().commit();
        session.close();  
    }



==websystiqueRest002==
http://websystique.com/springmvc/spring-mvc-4-restful-web-services-crud-example-resttemplate/
Na potrzeby angular.js
Odpalanie public static void main z poziomu mavena:
mvn -e exec:java -Dexec.mainClass="com.websystique.springmvc.SpringRestTestClient"
Na podstawie:
http://www.vineetmanohar.com/2009/11/3-ways-to-run-java-main-from-maven/
Klasa może być zarówno w main jak i test



TODO:
com.fasterxml.jackson.annotation.JsonProperty;
com.fasterxml.jackson.annotation.JsonIgnoreProperties;


keystores
@Qualifier

TODO Captcha:
org.springframework.http.converter.json.MappingJackson2HttpMessageConverter
org.springframework.util.LinkedMultiValueMap;

TODO jsp custom functions

TODO junit theories datapoints

Collection/List stream filter map
org.springframework.util.MultiValueMap;
org.springframework.web.client.RestTemplate

TODO Rabbitmq?:
org.springframework.amqp.core.Queue;
org.springframework.amqp.rabbit.core.RabbitAdmin;

TODO Szyfrowanie oraz klucze (RSAHelper):
java.io.IOException;
java.security.InvalidKeyException;
java.security.NoSuchAlgorithmException;
java.security.Signature;
java.security.SignatureException;
java.security.interfaces.RSAPrivateKey;
java.security.interfaces.RSAPublicKey;
java.security.spec.InvalidKeySpecException;
java.util.Arrays;
javax.crypto.BadPaddingException;
javax.crypto.Cipher;
javax.crypto.IllegalBlockSizeException;
javax.crypto.NoSuchPaddingException;
org.apache.commons.codec.binary.Base64;
org.apache.logging.log4j.LogManager;
org.apache.logging.log4j.Logger;
pl.ipakiet.commons.utils.CryptoUtils;


Krycie testów:
http://www.mkyong.com/qa/maven-cobertura-code-coverage-example/

TODO:
Testy @Mock, @InjectMocks, @Spy, 
    public void setUpGeneral(){
        userCreated = false;
        userDao = new InMemoryUserDao();
        MockitoAnnotations.initMocks(this);
        Mockito.when(discountDao.getAllByKey((String) Mockito.anyObject())).thenReturn(discounts);
        Mockito.mock(ApplicationContext.class);
        Authentication authentication = Mockito.mock(Authentication.class);
        SecurityContext securityContext = Mockito.mock(SecurityContext.class);
        Mockito.when(securityContext.getAuthentication()).thenReturn(authentication);
        SecurityContextHolder.setContext(securityContext);
        Mockito.when(SecurityContextHolder.getContext().getAuthentication().getPrincipal()).thenReturn(getOrCreateUser());
        Mockito.when(request.getContextPath()).thenReturn("localhost:8080/panel");
    }


log4j:
http://www.mkyong.com/logging/log4j-log4j-properties-examples/

== obiadoxml ==
projekt z konfiguracją w xmlu w lokacji src/main/webapp/WEB-INF/config
chce sprawdzić, czy można dodać katalog do ścieżki classpath w mavenie, oraz, czy możliwe jest trzymanie konfiguracji xmlowych w różnych lokalizacjacha, oraz jak je zaczytywać do testów

mvn archetype:generate -DgroupId=com.kkolcz.obiadoxml -DartifactId=obiadoxml -Dpackage=com.kkolcz.obiadoxml -Dversion=1.0
mvn archetype:generate -DgroupId=com.kkolcz.obiadoxml -DartifactId=obiadoxml -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false -Dpackage=com.kkolcz.obiadoxml -Dversion=1.0
mkdir test
SpringInAction/chapter05_tmp01
kopia pom.xml z obiado. Generalnie wszystkie potrzebne dependencies mavena.

webapp web-inf classpath

maven spring test resources
http://stackoverflow.com/questions/10104372/testing-with-spring-and-maven-applicationcontext

webapp web-inf spring configuration classpath
http://forum.spring.io/forum/spring-projects/container/49585-how-to-get-contextconfiguration-using-web-inf-applicationcontext-xml

http://stackoverflow.com/questions/14946298/spring-junit-load-application-context-for-tests
http://stackoverflow.com/questions/2699181/unit-test-in-maven-requires-access-to-the-src-main-webapp-directory
http://stackoverflow.com/questions/7613359/why-cant-i-access-src-test-resources-in-junit-test-run-with-maven
https://spring.io/blog/2012/11/07/spring-framework-3-2-rc1-new-testing-features


==websystiqueBasicMvc003FormValidation==
http://websystique.com/springmvc/spring-4-mvc-form-validation-with-hibernate-jsr-validator-resource-handling-using-annotations/

==validationExample001==
Chcę odpalić przykład walidacji na kilku polach klasy w metodzie main (bez springa). Powód - nie działa walidacji w projekcie obiado (password i passwordMatches)
mvn archetype:generate -DgroupId=com.kkolcz.validationExample001 -DartifactId=validationExample001 -DinteractiveMode=false -Dpackage=com.kkolcz
http://in.relation.to/2008/03/25/bean-validation-sneak-peek-part-i/
http://in.relation.to/2008/04/01/bean-validation-sneak-peek-part-ii-custom-constraints/#H-ClasslevelConstraints
http://stackoverflow.com/questions/1972933/cross-field-validation-with-hibernate-validator-jsr-303
cd validationExample001
mvn compile exec:java -Dexec.mainClass=com.kkolcz.App -Dexec.cleanupDaemonThreads=false


nie chce mi się robić wszystkich importów w vimie. Sprawdzę łatwiejszą klase.
==validationExample002==
Chcę odpalić przykład walidacji na kilku polach klasy w metodzie main (bez springa). Powód - nie działa walidacji w projekcie obiado (password i passwordMatches)
mvn archetype:generate -DgroupId=com.kkolcz.validationExample002 -DartifactId=validationExample002 -DinteractiveMode=false -Dpackage=com.kkolcz
http://stackoverflow.com/questions/1972933/cross-field-validation-with-hibernate-validator-jsr-303
https://docs.jboss.org/hibernate/validator/5.0/reference/en-US/html/validator-customconstraints.html#example-using-checkcase

junit test not running
problem z odpaleniem testów junit
dodanie sekcji build w pliku pom.xml mavena
maven-compiler-plugin
mavne-surefire-plugin

Wymagane dependencies
http://hibernate.org/validator/documentation/getting-started/

Log4j:
http://www.mkyong.com/logging/log4j-log4j-properties-examples/


==mailingExample==
Próba odtworzenia konfiguracji malingu w powerhosting
Struktura projektu na podstawie mkyong:
http://www.mkyong.com/spring/quick-start-maven-spring-example/

dodaję katalog src/main/resources
konfiguracja springa w src/main/resources/springConfig.xml
W konfiguracji dodaję beana helloWorld

W App tworzę kontekst aplikacji: 
ApplicationContext context = new ClassPathXmlApplicationContext( "springConfig.xml");

Dodaje maven dependencies do pom.xml (ściągam ze SpringInAction chapter02 - minimalny plik)

Znalezione w websystiqueHibernate001Hello:
mvn compile exec:java -Dexec.mainClass=com.kkolcz.App

Działa!
Setupuje posftix jako lokalny smtp server
https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-postfix-as-a-send-only-smtp-server-on-ubuntu-14-04
sudo apt-get install mailutils
sudo apt-get install postfix
vim /etc/posftix/main.cf
inet_interfaces = localhost
sudo service postfix restart
echo "This is the body of the email" | mail -s "This is the subject line" kkolcz@power.com.pl

Trochę nie działa, próbuję z FakeSMTP:
https://nilhcem.github.io/FakeSMTP/
http://blog.codeleak.pl/2014/09/testing-mail-code-in-spring-boot.html
mail.protocol=smtp
mail.host=localhost
mail.port=25
mail.smtp.auth=false
mail.smtp.starttls.enable=false
mail.from=me@localhost
mail.username=
mail.password=
Przykładowa konfiguracja xml:
http://howtodoinjava.com/spring/spring-core/send-email-with-spring-javamailsenderimpl-example/


## springIntegration014
mvn archetype:generate -DgroupId=siia.helloworld.channel -DartifactId=springIntegration014 -DarchetypeArtifactId=maven-archetype-quickstart -Dpackage=siia.helloworld.channel -DinteractiveMode=false

mvn compile exec:java -Dexec.mainClass=siia.helloworld.channel.HelloWorldExample

Korzystam również z tutoriala:
http://www.javaworld.com/article/2142107/spring-framework/open-source-java-projects-spring-integration.html

### odpalenie z jara
Potrzebne pluginy:
<artifactId>maven-compiler-plugin</artifactId>
<artifactId>maven-jar-plugin</artifactId>
<artifactId>maven-dependency-plugin</artifactId>

mvn clean install

uruchomienie z mvn:
mvn compile exec:java -Dexec.mainClass=siia.helloworld.channel.HelloWorldExample

uruchomienie z java -jar:
cd target
java -jar hello-spring-integration.jar

## springRabbit
https://www.javacodegeeks.com/2015/01/high-available-amqp-backed-message-channels-via-spring-integration-and-rabbitmq.html

mvn archetype:generate -DgroupId=com.onlinetechvision -DartifactId=sprintRabbit -DarchetypeArtifactId=maven-archetype-quickstart -Dpackage=com.onlinetechvision -DinteractiveMode=false

## springScheduler001
chcę sprawdzic, czy nullPointerException wywala springowy scheduler

mvn archetype:generate -DgroupId=com.kkolcz -DartifactId=springScheduler001 -DarchetypeArtifactId=maven-archetype-quickstart -Dpackage=com.kkolcz -DinteractiveMode=false

pierwszy tutorial - websystique:
http://websystique.com/spring/spring-job-scheduling-using-xml-configuration/


mvn compile exec:java -Dexec.mainClass=com.kkolcz.App

drugi tutorial - websystique:
http://websystique.com/spring/spring-job-scheduling-with-scheduled-enablescheduling-annotations/

dodanie do springConfig.xml:
<task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>
<task:executor id="myExecutor" pool-size="5"/>

umożliwiło odczytywanie annotacji @Scheduled w klasie PollWatcher

https://spring.io/guides/gs/scheduling-tasks/
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html

Z tego co pamiętam problem był taki, że scheduler miał limit wątków ustawiony na 1, a zadanie downgreadowania hostingu wchodziło w oczekiwanie, co powodowało wyczerpanie limitu w schedulerze, przez co maile nie były wysyłane.

TODO - potwierdzić to z null pointer exception, prawdopodobnie z tego co pamiętam nie miało to wpływu na schedulera.

## springScheduler002
Chcę sprawdzić, w jaki sposób traktowane są otwarte wątki (w stanie object.wait()) w schedulerze w momencie zamykania aplikacji.

mvn archetype:generate -DgroupId=com.kkolcz -DartifactId=springScheduler002 -DarchetypeArtifactId=maven-archetype-quickstart -Dpackage=com.kkolcz -DinteractiveMode=false

dodanie w pakiecie conifg klasy AppConfig z annotacjami:
    @Configuration
    @EnableWebMvc
    @ComponentScan(basePackages = "com.kkolcz")
    oraz implementującą metody:
    @Bean
    public ViewResolver viewResolver()
    @Bean
    public MessageSource messageSource()

ddodanie w pakiecie conifg klasy AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer 

dodanie pakietu views w WEB-INF (konfiguracja viewResolver)

dodanie controller/AppController.java - głownego kontroler aplikacji

@Controller
@RequestMapping("/")
public class AppController {
 
    @RequestMapping(value = { "/" }, method = RequestMethod.GET)
    public String home() {
        return "index";
    }
}

dodanie do pom.xml dependencies:
  <artifactId>junit</artifactId>
  <artifactId>spring-core</artifactId>
  <artifactId>spring-web</artifactId>
  <artifactId>spring-webmvc</artifactId>
  <artifactId>javax.servlet-api</artifactId>
  <artifactId>jstl</artifactId>
  <artifactId>javax.servlet.jsp-api</artifactId>

dodanie do pom.xml pluginów:
  <artifactId>maven-war-plugin</artifactId>
  <artifactId>maven-compiler-plugin</artifactId>


mvn clean package
root$ cp /target/springScheduler002 /opt/tomcat/webapps 
root$ cd /opt/tomcat
root$ ./bin/startup.sh

aby zadziałał scheduler, dodać do AppConfig:
@EnableScheduling





## Erlang
https://howistart.org/posts/erlang/1

Zsh - przyjrzeć się konsolce
https://github.com/robbyrussell/oh-my-zsh
http://www.zsh.org/


## rabbit
mvn -B archetype:generate -DarchetypeGroupId=com.kkolcz.rabbit -DgroupId=com.kkolcz.rabbit -DartifactId=rabbitapp
mvn compile exec:java -Dexec.mainClass=com.kkolcz.rabbit.App

https://www.rabbitmq.com/tutorials/tutorial-one-java.html
